# https://github.com/grf-labs/sufrep


function list means_or_median_encode (const list X "Exogenous regressors",
                                      const series G "Holding group IDs",
                                      const bool use_median[0] "Median instead of mean encoding",
                                      const bool verbose[0] "Print details")
    /* Function actually computing means/median_encoder */

    string operation = "mean"
    operation = (use_median) ? "median" : operation

    list R = null
    loop foreach i X -q
        list R += genseries(sprintf("%s_%s", varname(X.$i), operation), \
          series_with_groupwise_stats(X.$i, G, operation, verbose))

        if verbose
            printf "\nInfo: Generated group-wise %s series %s.\n", operation, varname(X.$i)
        endif
    endloop

    return R
end function


function list median_encode (const list X "Exogenous regressors",
                             const series G "Holding group IDs",
                             const bool verbose[0])
    /* Group-wise median computation wrapper function */

    return means_or_median_encode(X, G, 1, verbose)
end function


function list means_encode (const list X "Exogenous regressors",
                            const series G "Holding group IDs",
                            const bool verbose[0])
    /* Group-wise mean computation wrapper function */

    return means_or_median_encode(X, G, 0, verbose)
end function


function series series_with_groupwise_stats (const series X "Exogenous regressors",
                                       const series G "Holding group IDs",
                                       const string operation "E.g. 'mean', 'sd' etc.",
                                       const bool verbose[0])
    /* Helper function for grouping series X by G, computing group-wise
       statistics. Group-wise stats are imposed as values for constructing
    a series */

    matrix agg = aggregate(X, G, @operation)
    matrix groups = values(G)
    series R = NA
    loop i=1..rows(groups) -q
        catch smpl G==groups[i] --restrict --replace --quiet
        if $error 
            if verbose
                printf "\nWarning: No observations exist for group G=%d\n", groups[i]
            endif            
            return R
        endif
        series R = agg[i,3]
    endloop
    smpl full

    return R
end function

function series series_with_groupwise_values (const series G,
                                               const matrix V "Column vector of G scalar values",
                                               const bool verbose[0])
    /* Helper function imposing group-wise values taken from vector V. The i-th entry
    in V is mapped onto the i-th group Gi. */
   
    matrix groups = values(G)
    series R = NA
    loop i=1..rows(groups) -q
        catch smpl G==groups[i] --restrict --replace --quiet
        
        if $error
            if verbose
                printf "\nWarning: No observation left for G = %d\n", groups[i]
            endif
            return R
        endif
        
        series R = V[i]
        smpl full			# TODO: For some reason --replace option does not work
    endloop
    smpl full

    return R
end function



function list pca_encode (const list X "Exogenous regressors of groupe-wise means",
                          const series G "Holding group IDs",
                          const int num_components[0::0] "Retrieve only first n PCs",
                          const bool mean_encode[1] "Run means_encode()",
                          const bool verbose[0])

    check_num_xlist_entries(X)
    check_num_components(X, num_components)

    if mean_encode
        list Xmean = means_encode(X, G)
    endif

    string verbose_opt = get_verbose_opt(verbose)

    if num_components==0
        string save_opt = "--save-all"			# PCA on group-wise mean values
    else
        string save_opt = sprintf("--save=%d", num_components)
    endif

    smpl G X --no-missing					# TODO: Maybe more efficient when put into means_encode()?

    if mean_encode
        pca Xmean @save_opt @verbose_opt
    else
        pca X @save_opt @verbose_opt			# Make use of pointer access for X
    endif

    list R = PC*
    smpl full
    
    return R
end function


function list low_rank_encode (list X "Exogenous regressors of groupe-wise means",
                               const series G "Holding group IDs",
                               const int num_components[0::0] "Retrieve only first n PCs",
                               const bool mean_encode[1] "Run means_encode()",
                               const bool verbose[0])
    /* SVD based encoding */

    check_num_xlist_entries(X)
    check_num_components(X, num_components)

    if mean_encode
        list X = means_encode(X, G)
    endif

    smpl G X --no-missing

    matrix U
    matrix V
    #matrix sv = svd({X}, &U, &V)
    matrix sv = tall_svd({X}, &U, &V)

    list R = null
    loop foreach i X -q
        list R += genseries(sprintf("SVD%d", i), U[,i])
        if num_components > 0
            if $i == num_components
                break
            endif
        endif
    endloop

    smpl full

    return R
end function


function list mnl_encode (const list X "Exogenous regressors of groupe-wise means",
                          const series G "Dependent variable holding group IDs",
                          const bool mean_encode[1] "Run means_encode()",
      const bool verbose[0])
    /* Multinomial logistic regression.
    Requires also coefficients from reference category which are, however,
    not returned by gretl. */

    check_num_xlist_entries(X)

    string verbose_opt = get_verbose_opt(verbose)

    if mean_encode
        list Xmean = means_encode(X, G)
    endif

    if mean_encode
        logit G const Xmean --multinomial @verbose_opt
    else
        logit G const X --multinomial @verbose_opt
    endif

    scalar pos_const = inlist($xlist, "const")

    # Group-wise coefficient i is stored in rows of beta
    matrix beta = zeros(1, $model.cblock) | \
      mshape($coeff, $model.cblock, $model.multinom)'	# rows: unit, cols: coeff
    if pos_const > 0
        beta = beta[, -pos_const]			# TODO: Shall we drop column of intercepts?
    endif

    if rows(beta) != rows(values(G))
        funcerr "ERROR: The no. of distinct groups (G) does not equal the no. of rows of matrix 'beta'"
    endif

    list R = null
    strings xnames = varnames(X)
    loop i=1..nelem(X) -q					# TODO: must '1+nelem(X)' in case the intercept is considered
        list R += genseries(sprintf("%s_mnl", xnames[i]), series_with_groupwise_values(G, beta[,i]))
    endloop

    return R
end function


function matrix tall_svd (const matrix X, matrix *U, matrix *V)
    /* Special-case svd when X has lots of rows and few columns.
    Written by Jack Lucchetti */

    scalar c = cols(X)
    matrix lambdas = eigensym(X'X, &V)
    lambdas = mreverse(sqrt(lambdas))'
    V = V[,seq(c,1)]
    U = X*(V./lambdas)
    
    return lambdas
end function



function void check_num_components (const list X, const int num_components)
    /* Helper function checking that number compoents supposed to store does not exceed list members */
    if num_components > nelem(X)
        funcerr "Argument num_components cannot be larger than length of list X."
    endif
end function

function void check_num_xlist_entries (const list X)
    /* Helper function checking number of elements in X */
    if nelem(X)<2
        funcerr "At least 2 series must be in list X."
    endif
end function

function string get_verbose_opt (const bool verbose)
    string verbose_opt = ""
    return (verbose==0) ? "--quiet" : verbose_opt
end function



